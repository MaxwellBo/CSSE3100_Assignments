% \RequirePackage[l2tabu, orthodox]{nag}

\documentclass{article}
\usepackage{fullpage}
\usepackage{oz}
\usepackage{definitions}
\usepackage{todonotes}

\newcommand{\GUARD}{(i \neq A.len\, \lor\, j \neq B.len\, \lor\, k \neq C.len)}
\newcommand{\ASSIGNMENT}{i, j, k, r := 0, 0, 0, 0}
\newcommand{\ENV}{i, j, k, r, D}
\newcommand{\POST}{D_{[0, r)} = A\, \cap\, B\, \cap\, C}
\newcommand{\INTERSECTION}[4]{D_{[0, {#1})} = A_{[0, {#2})}\, \cap\, B_{[0, {#3})}\, \cap\, C_{[0, {#4})}}
\newcommand{\BOUNDED}[4]{{#1} \in [0, D.len] ~\land~ {#2} \in [0, A.len] ~\land~ {#3} \in [0, B.len] ~\land~ {#4} \in [0, C.len]}
\newcommand{\VARIANTEXP}{(0 \leqslant V < V_0)}


\title{\bf Assignment 2: Verification}
\author{Maxwell Bo ~~ 43926871}

\begin{document}
\maketitle

\section{Part A}

Given

\begin{eqnarray*}
pre & \triangleq & D.len \geqslant max(\{A.len,\, B.len,\, C.len\})\\
        && \land~ sorted(A) ~\land~ sorted(B) ~\land~ sorted(C)
\end{eqnarray*}

and

\begin{eqnarray*}
post & \triangleq & \POST\\
\end{eqnarray*}

\DERIVE
\form{\ENV:[pre, post]}
\hint{\refsto} {Composition: middle predicate is \textit{inv}}
\form{\ENV:[pre, inv]; \ENV:[inv, post]}
\ENDDERIVE

where

\begin{eqnarray*}
inv & \triangleq & \INTERSECTION{r}{i}{j}{k}\\
        && \land~ \BOUNDED{r}{i}{j}{k}\\
\end{eqnarray*}
% HERE BE DRAGONS: Don't forgot that these ranges are noninclusive array slices

\DERIVE
\hint{\refsto} {Assignment: $pre \entails inv[i, j, k, r\backslash 0, 0, 0, 0]$}
\form{\ASSIGNMENT; \ENV:[inv, post]}
\ENDDERIVE

$\because$

\begin{eqnarray*}
inv[i, j, k, r \backslash 0, 0, 0, 0] 
    & \equiv & \INTERSECTION{0}{0}{0}{0}\\
        && \land~ \BOUNDED{0}{0}{0}{0}\\
    & \equiv & \emptyset = (\emptyset\, \cap\, \emptyset\, \cap\, \emptyset) ~\land~ (\true ~\land~ \true ~\land~ \true ~\land~ \true)\\
    & \equiv & \emptyset = \emptyset ~\land~ \true\\
    & \equiv & \true
\end{eqnarray*}

\DERIVE
\hint{\refsto} {Strengthen post: $inv \land \neg guard \entails post$}
\form{\ASSIGNMENT; \ENV:[inv, inv \land \neg guard]}
\ENDDERIVE
 % TODO: We could have ANDs if we want a sensible guard, or we have a ORs to match what the program has}
% Here be dragons, don't forgot to flip both of the signs if we need to

$\because$
\begin{eqnarray*}
guard & \triangleq & (i \neq A.len\, \lor\, j \neq B.len\, \lor\, k \neq C.len)
\end{eqnarray*}

\begin{eqnarray*}
inv \land \neg guard & \equiv & inv \land (i = A.len\, \land\, j = B.len\, \land k = C.len)
\end{eqnarray*}

Assuming $(i = A.len\, \land\, j = B.len\, \land k = C.len)$ holds, we can show that still\\ \[inv \land (i = A.len\, \land\, j = B.len\, \land k = C.len) ~\entails~ post\]

$\because$

\begin{eqnarray*}
inv \land (i = A.len\, \land\, j = B.len\, \land k = C.len) & \equiv & inv[i, j, k \backslash A.len, B.len, C.len]\\
& \equiv & \INTERSECTION{r}{A.len}{B.len}{C.len}\\
    && \land~ \BOUNDED{r}{A.len}{B.len}{C.len}\\
& \equiv & (\POST) ~\land~ (r \in [0, D.len] ~\land~ \true ~\land~ \true ~\land~ \true)\\
& \equiv & (\POST) ~\land~ (r \in [0, D.len])\\
\end{eqnarray*}

\begin{eqnarray*}
(\POST) ~\land~ (r \in [0, D.len]) &~\entails~& post\\
                                   &~\entails~& \POST
\end{eqnarray*}

\DERIVE
\hint{\refsto} {Repetition}
\form{
\begin{array}{l}
\ASSIGNMENT;\\
\Do~ \GUARD \rightarrow\\
    \t1 \ENV:[inv\, \land\, guard,~ inv\, \land\, (0 \leqslant V < V_0)]\\
\Od\\
\end{array}}
\ENDDERIVE

where

\begin{eqnarray*}
V & \triangleq & (A.len - i) + (B.len - j) + (C.len - k)\\
  & \triangleq & (A.len + B.len + C.len) - (i + j + k)
\end{eqnarray*}


\DERIVE
\hint{\refsto} {Selection: $inv\, \land\, guard \entails (G_1(i, j) \lor G_2(j, k) \lor G_3(k, i) \lor G_4(i, j, k))$}
\form{
\begin{array}{l}
\ASSIGNMENT;\\
\Do~ \GUARD \rightarrow\\
    \t1 \begin{array}{l}
        \If~ (A_i > B_j) \rightarrow \ENV:[(A_i > B_j) \land inv \land guard, inv \land \VARIANTEXP] \\
        \Choice~ (B_j > C_k) \rightarrow TODO\\
        \Choice~ (C_k > A_i) \rightarrow TODO\\
        \Fi~ ((A_i = B_j) \land (B_j = C_k)) \rightarrow TODO\\
    \end{array}\\
\Od\\
\end{array}}
\ENDDERIVE

where

\begin{eqnarray*}
G_1(i, j) & \triangleq & A_i > B_j\\
G_2(j, k) & \triangleq & B_j > C_k\\
G_3(k, i) & \triangleq & C_k > A_i\\
G_4(i, j, k) & \triangleq & (A_i = B_j) \land (B_j = C_k)\\
\end{eqnarray*}

and $\because$

\DERIVE
\form{G_1(i, j) \lor G_2(j, k) \lor G_3(k, i) \lor G_4(i, j, k)}
\hint {\equiv} {Expansion of the guard definitions}
\form{(A_i > B_j) \lor (B_j > C_k) \lor (C_k > A_i) \lor ((A_i = B_j) \land (B_j = C_k))} 
\hint{\equiv} {Transitivity}
\form{(A_i > B_j) \lor (B_j > C_k) \lor (C_k > A_i) \lor (A_i = B_j = C_k)} 
% \hint{\equiv} {TODO}
% \form{\neg\neg((A_i > B_j) \lor (B_j > C_k) \lor (C_k > A_i) \lor (A_i = B_j = C_k))} 
% \hint{\equiv} {TODO}
% \form{\neg((A_i \leqslant B_j) \land (B_j \leqslant C_k) \land (C_k \leqslant A_i) \land (A_i \neq B_j \neq C_k))} 
% \hint{\equiv} {TODO}
% \form{\neg((A_i = B_j = C_k) \land (A_i \neq B_j \neq C_k))} 
% \hint{\equiv} {TODO}
% \form{(A_i \neq B_j \neq C_k) \lor (A_i = B_j = C_k)} 
\ENDDERIVE




% Given 

% \[max(A,l,h,i) ~\defs~ \all j \in [l,h) \cdot (A_j \leq A_i) \land (l \leq i < h)\]   % \[ and \] tell Latex we are entering and leaving math mode

% suppose we wanted to show that the specification

% \[i,j:[A.len > 0, max(A,0,A.len,i)]\]

% is refined by

% \[i,j:=0,1;\\  % \\ adds a line break
% \begin{array}{l}
% \Do~ j < A.len \rightarrow\\
% \t1 \begin{array}{l}   % \t1 introduces a tab. The array environment allows us to write 
% \If~ A_j > A_i \rightarrow i:=j\\
% \Choice  A_j \leq A_i \rightarrow {\bf skip} \\
% \Fi; \\
% j:=j+1\\
% \end{array}\\
% \Od\\
% \end{array}\]

% Parts of the proof follow:

% \DERIVE
% \form{i,j:[A.len > 0, max(A,0,A.len,i)]}
% \hint{\refsto} {Strengthen post: $inv \land max(A,0,A.len,i) \entails max(A,0,A.len,i)$}  % $ changes between text and math mode
% \form{i,j:[A.len > 0, inv \land max(A,0,A.len,i)]}
% \hint{\equiv}{$max(A,0,A.len,i)$ is equivalent to $j = A.len$ when $inv$ is true}
% \form{i,j:[A.len > 0, inv \land j  = A.len]}
% \hint {\refsto} {Composition: mid predicate is $inv$}
% \form {i,j:[A.len > 0, inv]; i,j:[inv, inv \land j= A.len]}
% \hint {\refsto} {Assignment: $A.len > 0 \entails inv[i,j\backslash 0,1]$}
% \form { i,j:=0,1; i,j:[inv, inv \land j= A.len]}
% \ENDDERIVE
  
% The proof of the final step above is:

% \DERIVE
% \form{inv[i,j\backslash 0,1]}
% \hint{\equiv}{definition of $inv$}
% \form{max(A,0,j,i)[i,j\backslash 0,1]}
% \hint{\equiv}{apply substitution}
% \form{max(A,0,1,0)}
% \hint{\equiv}{since $A_0$ only element in $A_{[0,1)}$}
% \form{\true}
% \ENDDERIVE

% \pagebreak % forces a page break here

% Continuing the refinement:

% \DERIVE
% \form{i,j:[inv, inv \land j=A.len]}
% \hint{\refsto}{Repetition: $A.len-j$ is variant}
% \form{\begin{array}{l}   
% \Do~ j\neq A.len \rightarrow\\   
% \t1 i,j:[inv \land j< A.len, inv \land (0 \leq A.len-j < A.len-j_0)]\\  
% \Od \\
% \end{array}}
% \ENDDERIVE

% Here is another part of the proof involving other GCL notation:

% \DERIVE
% \form{i:[inv \land j< A.len, max(A,0,j+1,i)]}
% \hint{\refsto}{Selection: $P \entails A_i > A_j \lor A_j \leq A_i$, for any $P$}
% \form{\begin{array}{l}
% \If~ A_j > A_i \rightarrow i:[A_j > A_i \land inv \land j< A.len, max(A,0,j+1,i)]\\
% \Choice A_j \leq A_i \rightarrow i:[A_j \leq A_i \land inv \land j< A.len, max(A,0,j+1,i)]\\
% \Fi\\
% \end{array}}
% \hint{\sqsubseteq}{Assignment: $A_j > A_i \land inv \land j< A.len \entails max(A,0,j+1,i)[i\backslash j]$}
% \form{\begin{array}{l}
% \If~  A_j > A_i \rightarrow i:=j\\
% \Choice A_j \leq A_i \rightarrow i:[A_j \leq A_i \land inv \land j< A.len, max(A,0,j+1,i)]\\
% \Fi\\
% \end{array}}
% \hint{\refsto}{Skip: $A_j \leq A_i \land inv \land j< A.len \entails  max(A,0,j+1,i)$}
% \form{\begin{array}{l}
% \If~ A_j > A_i \rightarrow i:=j\\
% \Choice A_j \leq A_i \rightarrow {\Skip} \\
% \Fi\
% \end{array}}
% \ENDDERIVE
  
\end{document}

