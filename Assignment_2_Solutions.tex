% \RequirePackage[l2tabu, orthodox]{nag}

\documentclass{article}
\usepackage{fullpage}
\usepackage{oz}
\usepackage{definitions}
\usepackage{todonotes}

\newcommand{\GUARD}{(i \neq A.len\, \lor\, j \neq B.len\, \lor\, k \neq C.len)}
\newcommand{\ASSIGNMENT}{i, j, k, r := 0, 0, 0, 0}
\newcommand{\ENV}{i, j, k, r, D}


\title{\bf Assignment 2: Verification}
\author{Maxwell Bo ~~ 43926871}

\begin{document}
\maketitle

\section{Part A}

Given

\begin{eqnarray*}
pre & \triangleq & D.len \geqslant max(\{A.len,\, B.len,\, C.len\})\\
        && \land~ sorted(A) ~\land~ sorted(B) ~\land~ sorted(C)
\end{eqnarray*}

and

\begin{eqnarray*}
post & \triangleq & D = A\, \cap\, B\, \cap\, C\\
     & \triangleq & D_{[0, D.len)} = A_{[0, A.len)}\, \cap\, B_{[0, B.len)}\, \cap\, C_{[0, C.len)}
        % && \land r \in [0, D.len] ~\land~ i \in [0, A.len] ~\land~ j \in [0, B.len] ~\land~ k \in [0, C.len]\\
        % && \land (i = A.len\, \lor\, j = B.len\, \lor\, k = C.len)\\
\end{eqnarray*}

\DERIVE
\form{\ENV:[pre, post]}
\hint{\refsto} {Composition: middle predicate is \textit{inv}}
\form{\ENV:[pre, inv]; \ENV:[inv, post]}
\ENDDERIVE

where

\begin{eqnarray*}
inv & \triangleq & D_{[0, r)} = A_{[0, i)}\, \cap\, B_{[0, j)}\, \cap\, C_{[0, k)}\\
        && \land~ r \in [0, D.len] ~\land~ i \in [0, A.len] ~\land~ j \in [0, B.len] ~\land~ k \in [0, C.len]\\
\end{eqnarray*}
% HERE BE DRAGONS: Don't forgot that these ranges are noninclusive array slices

\DERIVE
\hint{\refsto} {Assignment: $pre \entails inv[i, j, k, r\backslash 0, 0, 0, 0]$}
\form{\ASSIGNMENT; \ENV:[inv, post]}
\ENDDERIVE

$\because$

\begin{eqnarray*}
inv[i, j, k, r\backslash 0, 0, 0, 0] 
    & \equiv & D_{[0, 0)} = A_{[0, 0)}\, \cap\, B_{[0, 0)}\, \cap\, C_{[0, 0)}\\
        && \land~ 0 \in [0, D.len] ~\land~ 0 \in [0, A.len] ~\land~ 0 \in [0, B.len] ~\land~ 0 \in [0, C.len]\\
    & \equiv & \emptyset = (\emptyset\, \cap\, \emptyset\, \cap\, \emptyset) ~\land~ (\true ~\land~ \true ~\land~ \true ~\land~ \true)\\
    & \equiv & \emptyset = \emptyset ~\land~ \true\\
    & \equiv & \true
\end{eqnarray*}

\DERIVE
\hint{\refsto} {Strengthen post: $inv \land \neg\GUARD \entails post$}
\form{\ASSIGNMENT; \ENV:[inv, inv \land \neg\GUARD]}
\ENDDERIVE
 % TODO: We could have ANDs if we want a sensible guard, or we have a ORs to match what the program has}
% Here be dragons, don't forgot to flip both of the signs if we need to

$\because$

\begin{eqnarray*}
inv \land \neg\GUARD \entails post & \equiv & inv \land (i = A.len\, \land\, j = B.len\, \land k = C.len) \entails post\\
                                   & \equiv & TODO
\end{eqnarray*}

% TODO REMOVE THIS
$((a \land b) \entails (a \land c)) \equiv (b \entails c)$

\DERIVE
\hint{\refsto} {Repetition}
\form{
\begin{array}{l}
\ASSIGNMENT;\\
\Do~ \GUARD \rightarrow\\
    \t1 \ENV:[inv\, \land\, \GUARD,~ inv\, \land\, (0 \leqslant V < V_0)]\\
\Od\\
\end{array}}
\ENDDERIVE

where

\begin{eqnarray*}
V & \triangleq & (A.len - i) + (B.len - j) + (C.len - k)\\
  & \triangleq & (A.len + B.len + C.len) - (i + j + k)
\end{eqnarray*}

\DERIVE
\hint{\refsto} {Selection: $inv\, \land\, \GUARD \entails (G_1 \lor G_2 \lor G_3 \lor G_4)$}
\form{
\begin{array}{l}
\ASSIGNMENT;\\
\Do~ \GUARD \rightarrow\\
    \t1 TODO\\
\Od\\
\end{array}}
\ENDDERIVE

where

\begin{eqnarray*}
G_1 & \triangleq & A_i > B_j\\
G_2 & \triangleq & B_j > C_k\\
G_3 & \triangleq & C_k > A_i\\
G_4 & \triangleq & (A_i = B_j) \land (B_j = C_k)\\
\end{eqnarray*}


% Given 

% \[max(A,l,h,i) ~\defs~ \all j \in [l,h) \cdot (A_j \leq A_i) \land (l \leq i < h)\]   % \[ and \] tell Latex we are entering and leaving math mode

% suppose we wanted to show that the specification

% \[i,j:[A.len > 0, max(A,0,A.len,i)]\]

% is refined by

% \[i,j:=0,1;\\  % \\ adds a line break
% \begin{array}{l}
% \Do~ j < A.len \rightarrow\\
% \t1 \begin{array}{l}   % \t1 introduces a tab. The array environment allows us to write 
% \If~ A_j > A_i \rightarrow i:=j\\
% \Choice  A_j \leq A_i \rightarrow {\bf skip} \\
% \Fi; \\
% j:=j+1\\
% \end{array}\\
% \Od\\
% \end{array}\]

% Parts of the proof follow:

% \DERIVE
% \form{i,j:[A.len > 0, max(A,0,A.len,i)]}
% \hint{\refsto} {Strengthen post: $inv \land max(A,0,A.len,i) \entails max(A,0,A.len,i)$}  % $ changes between text and math mode
% \form{i,j:[A.len > 0, inv \land max(A,0,A.len,i)]}
% \hint{\equiv}{$max(A,0,A.len,i)$ is equivalent to $j = A.len$ when $inv$ is true}
% \form{i,j:[A.len > 0, inv \land j  = A.len]}
% \hint {\refsto} {Composition: mid predicate is $inv$}
% \form {i,j:[A.len > 0, inv]; i,j:[inv, inv \land j= A.len]}
% \hint {\refsto} {Assignment: $A.len > 0 \entails inv[i,j\backslash 0,1]$}
% \form { i,j:=0,1; i,j:[inv, inv \land j= A.len]}
% \ENDDERIVE
  
% The proof of the final step above is:

% \DERIVE
% \form{inv[i,j\backslash 0,1]}
% \hint{\equiv}{definition of $inv$}
% \form{max(A,0,j,i)[i,j\backslash 0,1]}
% \hint{\equiv}{apply substitution}
% \form{max(A,0,1,0)}
% \hint{\equiv}{since $A_0$ only element in $A_{[0,1)}$}
% \form{\true}
% \ENDDERIVE

% \pagebreak % forces a page break here

% Continuing the refinement:

% \DERIVE
% \form{i,j:[inv, inv \land j=A.len]}
% \hint{\refsto}{Repetition: $A.len-j$ is variant}
% \form{\begin{array}{l}   
% \Do~ j\neq A.len \rightarrow\\   
% \t1 i,j:[inv \land j< A.len, inv \land (0 \leq A.len-j < A.len-j_0)]\\  
% \Od \\
% \end{array}}
% \ENDDERIVE

% Here is another part of the proof involving other GCL notation:

% \DERIVE
% \form{i:[inv \land j< A.len, max(A,0,j+1,i)]}
% \hint{\refsto}{Selection: $P \entails A_i > A_j \lor A_j \leq A_i$, for any $P$}
% \form{\begin{array}{l}
% \If~ A_j > A_i \rightarrow i:[A_j > A_i \land inv \land j< A.len, max(A,0,j+1,i)]\\
% \Choice A_j \leq A_i \rightarrow i:[A_j \leq A_i \land inv \land j< A.len, max(A,0,j+1,i)]\\
% \Fi\\
% \end{array}}
% \hint{\sqsubseteq}{Assignment: $A_j > A_i \land inv \land j< A.len \entails max(A,0,j+1,i)[i\backslash j]$}
% \form{\begin{array}{l}
% \If~  A_j > A_i \rightarrow i:=j\\
% \Choice A_j \leq A_i \rightarrow i:[A_j \leq A_i \land inv \land j< A.len, max(A,0,j+1,i)]\\
% \Fi\\
% \end{array}}
% \hint{\refsto}{Skip: $A_j \leq A_i \land inv \land j< A.len \entails  max(A,0,j+1,i)$}
% \form{\begin{array}{l}
% \If~ A_j > A_i \rightarrow i:=j\\
% \Choice A_j \leq A_i \rightarrow {\Skip} \\
% \Fi\
% \end{array}}
% \ENDDERIVE
  
\end{document}

