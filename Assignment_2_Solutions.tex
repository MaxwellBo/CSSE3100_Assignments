% \RequirePackage[l2tabu, orthodox]{nag}

\documentclass[a4paper]{article}
\usepackage{fullpage}
\usepackage{oz}
\usepackage{definitions}
\usepackage{todonotes}

\newcommand{\GUARD}{(i \neq A.len\, \lor\, j \neq B.len\, \lor\, k \neq C.len)}
\newcommand{\ASSIGNMENT}{i, j, k, r := 0, 0, 0, 0}
\newcommand{\ENV}{i, j, k, r, D}
\newcommand{\POST}{D_{[0, r)} = A\, \cap\, B\, \cap\, C}
\newcommand{\INTERSECTION}[4]{D_{[0, {#1})} = A_{[0, {#2})}\, \cap\, B_{[0, {#3})}\, \cap\, C_{[0, {#4})}}
\newcommand{\BOUNDED}[4]{{#1} \in [0, D.len] ~\land~ {#2} \in [0, A.len] ~\land~ {#3} \in [0, B.len] ~\land~ {#4} \in [0, C.len]}
\newcommand{\BOUNDEDNONINCLUSIVE}[3]{{#1} \in [0, A.len) ~\land~ {#2} \in [0, B.len) ~\land~ {#3} \in [0, C.len)}
\newcommand{\VARIANTEXP}{(0 \leqslant V < V_0)}
\newcommand{\IFCASE}[1]{{#1} \rightarrow \ENV:[{#1} \land inv \land guard,\, inv \land \VARIANTEXP]}
\newcommand{\GUARDUNION}{(A_i > B_j) \lor (B_j > C_k) \lor (C_k > A_i) \lor (A_i = B_j = C_k)}


\title{\bf Assignment 2: Verification}
\author{Maxwell Bo ~~ 43926871}

\begin{document}
\maketitle

\section{Part A}

Let

\begin{eqnarray*}
pre & \triangleq & D.len \geqslant max(\{A.len,\, B.len,\, C.len\})\\
        && \land~ sorted(A) ~\land~ sorted(B) ~\land~ sorted(C)
\end{eqnarray*}

\begin{eqnarray*}
post(r) & \triangleq & \POST\\
\end{eqnarray*}


\DERIVE
\form{\ENV:[pre, post(r)]}
\hint{\refsto} {Composition: middle predicate is \textit{inv}}
\form{\ENV:[pre, inv]; \ENV:[inv, post(r)]}
\ENDDERIVE

where

\begin{eqnarray*}
inv & \triangleq & \INTERSECTION{r}{i}{j}{k}\\
        && \land~ \BOUNDED{r}{i}{j}{k}\\
\end{eqnarray*}
% HERE BE DRAGONS: Don't forgot that these ranges are noninclusive array slices

\DERIVE
\hint{\refsto} {Assignment: $pre \entails inv[i, j, k, r\backslash 0, 0, 0, 0]$}
\form{\ASSIGNMENT; \ENV:[inv, post(r)]}
\ENDDERIVE

$\because$

\begin{eqnarray*}
inv[i, j, k, r \backslash 0, 0, 0, 0] 
    & \equiv & \INTERSECTION{0}{0}{0}{0}\\
        && \land~ \BOUNDED{0}{0}{0}{0}\\
    & \equiv & \emptyset = (\emptyset\, \cap\, \emptyset\, \cap\, \emptyset) ~\land~ (\true ~\land~ \true ~\land~ \true ~\land~ \true)\\
    & \equiv & \emptyset = \emptyset ~\land~ \true\\
    & \equiv & \true
\end{eqnarray*}

\DERIVE
\hint{\refsto} {Strengthen post: $inv \land \neg guard \entails post(r)$}
\form{\ASSIGNMENT; \ENV:[inv, inv \land \neg guard]}
\ENDDERIVE
 % TODO: We could have ANDs if we want a sensible guard, or we have a ORs to match what the program has}
% Here be dragons, don't forgot to flip both of the signs if we need to

where $guard$ is a function that takes $i$, $j$, $k$ as implicit parameters, s.t.

\begin{eqnarray*}
guard(i, j, k) & \triangleq & (i \neq A.len\, \lor\, j \neq B.len\, \lor\, k \neq C.len)
\end{eqnarray*}

$\therefore$

\begin{eqnarray*}
inv \land \neg guard & \equiv & inv \land (i = A.len\, \land\, j = B.len\, \land k = C.len)
\end{eqnarray*}

Assuming $(i = A.len\, \land\, j = B.len\, \land k = C.len)$ holds, we can show that still\\ \[inv \land (i = A.len\, \land\, j = B.len\, \land k = C.len) ~\entails~ post(r)\]

$\because$

\begin{eqnarray*}
inv \land (i = A.len\, \land\, j = B.len\, \land k = C.len) & \equiv & inv[i, j, k \backslash A.len, B.len, C.len]\\
& \equiv & \INTERSECTION{r}{A.len}{B.len}{C.len}\\
    && \land~ \BOUNDED{r}{A.len}{B.len}{C.len}\\
& \equiv & (\POST) ~\land~ (r \in [0, D.len] ~\land~ \true ~\land~ \true ~\land~ \true)\\
& \equiv & (\POST) ~\land~ (r \in [0, D.len])\\
\end{eqnarray*}

\begin{eqnarray*}
(\POST) ~\land~ (r \in [0, D.len]) &~\entails~& post(r)\\
                                   &~\entails~& \POST
\end{eqnarray*}

\DERIVE
\hint{\refsto} {Repetition}
\form{
\begin{array}{l}
\ASSIGNMENT;\\
\Do~ \GUARD \rightarrow\\
    \t1 \ENV:[inv\, \land\, guard,~ inv\, \land\, \VARIANTEXP]\\
\Od\\
\end{array}}
\ENDDERIVE

where

\begin{eqnarray*}
V & \triangleq & (A.len - i) + (B.len - j) + (C.len - k)\\
  & \triangleq & (A.len + B.len + C.len) - (i + j + k)
\end{eqnarray*}


\DERIVE
\hint{\doesntrefsto} {Selection: $inv\, \land\, guard \not\entails (G_1(i, j) \lor G_2(j, k) \lor G_3(k, i) \lor G_4(i, j, k))$}
\form{
\begin{array}{l}
\ASSIGNMENT;\\
\Do~ \GUARD \rightarrow\\
    \t1 \begin{array}{l}
        \If~    \IFCASE{(A_i > B_j)}\\
        \Choice~ \IFCASE{(B_j > C_k)}\\
        \Choice~ \IFCASE{(C_k > A_i)}\\
        \Fi~     \IFCASE{(A_i = B_j) \land (B_j = C_k)}\\
    \end{array}\\
\Od\\
\end{array}}
\ENDDERIVE

where

\begin{eqnarray*}
G_1(i, j) & \triangleq & A_i > B_j\\
G_2(j, k) & \triangleq & B_j > C_k\\
G_3(k, i) & \triangleq & C_k > A_i\\
G_4(i, j, k) & \triangleq & (A_i = B_j) \land (B_j = C_k)\\
\end{eqnarray*}

$\therefore$

\DERIVE
\form{G_1(i, j) \lor G_2(j, k) \lor G_3(k, i) \lor G_4(i, j, k)}
\hint {\equiv} {Expansion of the guard definitions}
\form{(A_i > B_j) \lor (B_j > C_k) \lor (C_k > A_i) \lor ((A_i = B_j) \land (B_j = C_k))} 
\hint{\equiv} {Transitivity}
\form{\GUARDUNION} 
\ENDDERIVE

Actions that have undefined behaviour, such as out-of-bounds array indexing, are inexpressible in the Guarded Query Language. Therefore, for any array-index pairing $A_i$, there is an implicit constraint that $i \in [0, A.len)$.\\

Thus

\begin{eqnarray*}
\GUARDUNION & \equiv & (\GUARDUNION)\\
    && \land~ (\BOUNDEDNONINCLUSIVE{i}{j}{k})
\end{eqnarray*}

\begin{eqnarray*}
inv \land guard  & \not\entails & (\GUARDUNION)\\
    && \land~ (\BOUNDEDNONINCLUSIVE{i}{j}{k})
\end{eqnarray*}


By counter-example, let $r, i, j, k = 0, A.len, 0, 0$.

\begin{eqnarray*}
inv[i, j, k, r \backslash 0, A.len, 0, 0] & \equiv & \INTERSECTION{0}{A.len}{0}{0}\\
    && \land \BOUNDED{0}{A.len}{0}{0}\\
    & \equiv & \emptyset = (A\, \cap\, \emptyset\, \cap\, \emptyset) ~\land~ (\true ~\land~ \true ~\land~ \true ~\land~ \true)\\
    & \equiv & \emptyset = \emptyset ~\land~ \true\\
    & \equiv & \true
\end{eqnarray*} 



% Where, by counter-example, $r, i, j, k = 0, A.len, 0, 0$ satisfies both the index constraints of $inv$\footnote{$\BOUNDED{r}{i}{j}{k}$} and the $\Do$ guard\footnote{$\GUARD$}, but not that of the $\If$ guard union\footnote{$\BOUNDEDNONINCLUSIVE{i}{j}{k}$\\

\textbf{The specification does not refine to the provided program.}



% \DERIVE
% \hint {\doesntrefsto} {Assignment: $(A_i > B_j) \land inv \land guard \not\entails (inv \land \VARIANTEXP)[j \backslash j + 1]$}
% \form{
% \begin{array}{l}
% \ASSIGNMENT;\\
% \Do~ \GUARD \rightarrow\\
%     \t1 \begin{array}{l}
%         \If~   (A_i > B_j) \rightarrow j := j + 1\\
%         \Choice~ \IFCASE{(B_j > C_k)}\\
%         \Choice~ \IFCASE{(C_k > A_i)}\\
%         \Fi~     \IFCASE{(A_i = B_j) \land (B_j = C_k)}\\
%     \end{array}\\
% \Od\\
% \end{array}}
% \ENDDERIVE

% $\because$

% \begin{eqnarray*}
% (A_i > B_j) \land inv \land guard & \not\entails & (inv \land \VARIANTEXP)[j \backslash j + 1]\\
% &\notentails&  \
% \end{eqnarray*}




% Given 

% \[max(A,l,h,i) ~\defs~ \all j \in [l,h) \cdot (A_j \leq A_i) \land (l \leq i < h)\]   % \[ and \] tell Latex we are entering and leaving math mode

% suppose we wanted to show that the specification

% \[i,j:[A.len > 0, max(A,0,A.len,i)]\]

% is refined by

% \[i,j:=0,1;\\  % \\ adds a line break
% \begin{array}{l}
% \Do~ j < A.len \rightarrow\\
% \t1 \begin{array}{l}   % \t1 introduces a tab. The array environment allows us to write 
% \If~ A_j > A_i \rightarrow i:=j\\
% \Choice  A_j \leq A_i \rightarrow {\bf skip} \\
% \Fi; \\
% j:=j+1\\
% \end{array}\\
% \Od\\
% \end{array}\]

% Parts of the proof follow:

% \DERIVE
% \form{i,j:[A.len > 0, max(A,0,A.len,i)]}
% \hint{\refsto} {Strengthen post: $inv \land max(A,0,A.len,i) \entails max(A,0,A.len,i)$}  % $ changes between text and math mode
% \form{i,j:[A.len > 0, inv \land max(A,0,A.len,i)]}
% \hint{\equiv}{$max(A,0,A.len,i)$ is equivalent to $j = A.len$ when $inv$ is true}
% \form{i,j:[A.len > 0, inv \land j  = A.len]}
% \hint {\refsto} {Composition: mid predicate is $inv$}
% \form {i,j:[A.len > 0, inv]; i,j:[inv, inv \land j= A.len]}
% \hint {\refsto} {Assignment: $A.len > 0 \entails inv[i,j\backslash 0,1]$}
% \form { i,j:=0,1; i,j:[inv, inv \land j= A.len]}
% \ENDDERIVE
  
% The proof of the final step above is:

% \DERIVE
% \form{inv[i,j\backslash 0,1]}
% \hint{\equiv}{definition of $inv$}
% \form{max(A,0,j,i)[i,j\backslash 0,1]}
% \hint{\equiv}{apply substitution}
% \form{max(A,0,1,0)}
% \hint{\equiv}{since $A_0$ only element in $A_{[0,1)}$}
% \form{\true}
% \ENDDERIVE

% \pagebreak % forces a page break here

% Continuing the refinement:

% \DERIVE
% \form{i,j:[inv, inv \land j=A.len]}
% \hint{\refsto}{Repetition: $A.len-j$ is variant}
% \form{\begin{array}{l}   
% \Do~ j\neq A.len \rightarrow\\   
% \t1 i,j:[inv \land j< A.len, inv \land (0 \leq A.len-j < A.len-j_0)]\\  
% \Od \\
% \end{array}}
% \ENDDERIVE

% Here is another part of the proof involving other GCL notation:

% \DERIVE
% \form{i:[inv \land j< A.len, max(A,0,j+1,i)]}
% \hint{\refsto}{Selection: $P \entails A_i > A_j \lor A_j \leq A_i$, for any $P$}
% \form{\begin{array}{l}
% \If~ A_j > A_i \rightarrow i:[A_j > A_i \land inv \land j< A.len, max(A,0,j+1,i)]\\
% \Choice A_j \leq A_i \rightarrow i:[A_j \leq A_i \land inv \land j< A.len, max(A,0,j+1,i)]\\
% \Fi\\
% \end{array}}
% \hint{\sqsubseteq}{Assignment: $A_j > A_i \land inv \land j< A.len \entails max(A,0,j+1,i)[i\backslash j]$}
% \form{\begin{array}{l}
% \If~  A_j > A_i \rightarrow i:=j\\
% \Choice A_j \leq A_i \rightarrow i:[A_j \leq A_i \land inv \land j< A.len, max(A,0,j+1,i)]\\
% \Fi\\
% \end{array}}
% \hint{\refsto}{Skip: $A_j \leq A_i \land inv \land j< A.len \entails  max(A,0,j+1,i)$}
% \form{\begin{array}{l}
% \If~ A_j > A_i \rightarrow i:=j\\
% \Choice A_j \leq A_i \rightarrow {\Skip} \\
% \Fi\
% \end{array}}
% \ENDDERIVE
  
\end{document}

